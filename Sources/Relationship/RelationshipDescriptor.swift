// RelationshipDescriptor.swift
// Relationship - Relationship descriptor for Persistable types
//
// Reference: SwiftData @Relationship macro

import Core

// MARK: - DeleteRule

/// Delete rule when the related model is deleted
///
/// Controls what happens to items that reference the deleted item.
///
/// **Reference**: SwiftData `Schema.Relationship.DeleteRule`
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct Order {
///     @Relationship(Customer.self, deleteRule: .nullify)
///     var customerID: String?
/// }
/// ```
public enum DeleteRule: String, Sendable, Codable, Hashable {
    /// Set related model's FK field to nil (default)
    ///
    /// When the referenced item is deleted, the FK in referencing
    /// items is set to nil, breaking the relationship but preserving
    /// the referencing records.
    ///
    /// **Example**: Deleting a Customer sets `order.customerID = nil`
    /// for all related Orders.
    case nullify

    /// Delete all referencing items
    ///
    /// When the referenced item is deleted, all items that reference
    /// it are also deleted recursively.
    ///
    /// **Warning**: Be careful with bidirectional cascade rules to
    /// avoid infinite deletion loops.
    ///
    /// **Example**: Deleting a Customer also deletes all their Orders.
    case cascade

    /// Prevent deletion if referencing items exist
    ///
    /// Throws an error if attempting to delete an item that is
    /// referenced by other items. The user must delete or reassign
    /// referencing items first.
    ///
    /// **Example**: Cannot delete a Customer if they have Orders.
    case deny

    /// Do nothing (may leave orphans)
    ///
    /// The relationship is not maintained on deletion. Referencing items
    /// may reference a deleted item (orphaned foreign keys).
    ///
    /// **Use Case**: When orphaned references are acceptable or
    /// cleanup is handled elsewhere.
    case noAction
}

// MARK: - RelationshipDescriptor

/// Descriptor for a relationship between Persistable types
///
/// Conforms to `Descriptor` protocol, enabling storage in `Persistable.descriptors`.
/// Generated by the `@Persistable` macro when it detects `@Relationship` attributes.
///
/// **Usage**:
/// ```swift
/// // Access relationship metadata
/// let descriptors = Order.relationshipDescriptors
/// for descriptor in descriptors {
///     print("Relationship: \(descriptor.propertyName) -> \(descriptor.relatedTypeName)")
/// }
/// ```
public struct RelationshipDescriptor: Descriptor, Sendable, Codable {
    // MARK: - Properties

    /// Relationship name (used as Descriptor.name)
    ///
    /// Format: `{OwnerType}_{relationshipPropertyName}`
    /// Example: `"Order_customer"` for `Order.customerID -> Customer`
    public let name: String

    /// FK field name in the owning type
    ///
    /// Example: For `@Relationship(Customer.self) var customerID: String?`,
    /// this is `"customerID"`
    public let propertyName: String

    /// Name of the related Persistable type
    ///
    /// Example: For `@Relationship(Customer.self)`, this is `"Customer"`
    public let relatedTypeName: String

    /// Delete rule for this relationship
    ///
    /// Determines what happens to referencing items when the referenced item is deleted.
    public let deleteRule: DeleteRule

    /// Whether this is a to-many relationship
    ///
    /// - `true`: `var orderIDs: [String]` (array of FK)
    /// - `false`: `var customerID: String?` (single optional FK)
    public let isToMany: Bool

    /// Relationship property name (derived from FK field name)
    ///
    /// - `"customerID"` → `"customer"`
    /// - `"orderIDs"` → `"orders"`
    ///
    /// Used for generating Snapshot extension properties.
    public let relationshipPropertyName: String

    // MARK: - Initialization

    public init(
        name: String,
        propertyName: String,
        relatedTypeName: String,
        deleteRule: DeleteRule,
        isToMany: Bool,
        relationshipPropertyName: String
    ) {
        self.name = name
        self.propertyName = propertyName
        self.relatedTypeName = relatedTypeName
        self.deleteRule = deleteRule
        self.isToMany = isToMany
        self.relationshipPropertyName = relationshipPropertyName
    }

    /// Convenience initializer that derives name and relationshipPropertyName
    public init(
        ownerTypeName: String,
        propertyName: String,
        relatedTypeName: String,
        deleteRule: DeleteRule,
        isToMany: Bool
    ) {
        let relationshipPropertyName = Self.deriveRelationshipName(
            from: propertyName,
            isToMany: isToMany
        )
        self.name = "\(ownerTypeName)_\(relationshipPropertyName)"
        self.propertyName = propertyName
        self.relatedTypeName = relatedTypeName
        self.deleteRule = deleteRule
        self.isToMany = isToMany
        self.relationshipPropertyName = relationshipPropertyName
    }

    // MARK: - Computed Properties

    /// Whether this is a to-one relationship
    public var isToOne: Bool {
        !isToMany
    }

    // MARK: - Static Methods

    /// Derive relationship property name from FK field name
    ///
    /// - `"customerID"` → `"customer"`
    /// - `"orderIDs"` → `"orders"`
    public static func deriveRelationshipName(from fkFieldName: String, isToMany: Bool) -> String {
        if isToMany {
            // "orderIDs" → "orders"
            let base = fkFieldName.replacingOccurrences(of: "IDs", with: "")
            return base + "s"
        } else {
            // "customerID" → "customer"
            return fkFieldName.replacingOccurrences(of: "ID", with: "")
        }
    }
}

// MARK: - CustomStringConvertible

extension RelationshipDescriptor: CustomStringConvertible {
    public var description: String {
        let cardinality = isToMany ? "to-many" : "to-one"
        return "RelationshipDescriptor(\(propertyName) -> \(relatedTypeName), \(cardinality), \(deleteRule))"
    }
}

// MARK: - Persistable Extension

extension Persistable {
    /// Type-safe access to relationship descriptors
    ///
    /// Filters `descriptors` to return only `RelationshipDescriptor` instances.
    ///
    /// **Requires**: `import Relationship`
    public static var relationshipDescriptors: [RelationshipDescriptor] {
        descriptors.compactMap { $0 as? RelationshipDescriptor }
    }
}
