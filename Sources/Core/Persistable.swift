/// Persistable protocol - Storage-independent persistable model interface
///
/// This protocol defines the metadata and serialization interface for persistable data models.
/// It is storage-independent and can be used across all data model layers:
/// - RecordLayer (RDB-like): Structured records
/// - DocumentLayer (Document store): Flexible documents
/// - VectorLayer (Vector search): Vector embeddings with similarity search
/// - GraphLayer (Graph database): Nodes and edges with relationships
///
/// **Platform Support**:
/// - Client (iOS/macOS): Model definitions, metadata, Codable serialization
/// - Server (macOS/Linux): Full persistence with FDBRuntime
///
/// **Implementation**: Generated by @Persistable macro
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct User {
///     var id: String = ULID().ulidString  // Optional: auto-generated if omitted
///
///     #Directory<User>("users")
///     #Index<User>([\.email], unique: true)
///
///     var email: String
///     var name: String
/// }
/// ```
///
/// **Generated Properties**:
/// - `id`: Unique identifier (auto-generated ULID if not defined)
/// - `persistableType`: Type identifier (e.g., "User")
/// - `allFields`: All field names
/// - `indexDescriptors`: Index metadata
///
/// **ID Behavior**:
/// - If user defines `id` field: uses that type and default value
/// - If user omits `id` field: macro adds `var id: String = ULID().ulidString`
/// - `id` is NOT included in the generated initializer
@dynamicMemberLookup
public protocol Persistable: Sendable, Codable {
    // MARK: - ID

    /// The type of the unique identifier
    ///
    /// **IMPORTANT**: When used with FDBRuntime (server-side), the ID type MUST also
    /// conform to `TupleElement` for FDB key encoding. This cannot be enforced at
    /// compile time because FDBModel is platform-independent (iOS/macOS clients).
    ///
    /// **Supported ID types** (conform to TupleElement):
    /// - `String` (recommended: ULID for sortable unique IDs)
    /// - `Int64`, `Int32`, `Int16`, `Int8`, `Int`
    /// - `UInt64`, `UInt32`, `UInt16`, `UInt8`, `UInt`
    /// - `UUID`
    /// - `Double`, `Float`
    /// - `Bool`
    /// - `Data`, `[UInt8]`
    ///
    /// **Unsupported** (will cause runtime error in FDBRuntime):
    /// - Custom structs/classes (unless they conform to TupleElement)
    /// - Enums (unless raw value is a supported type)
    associatedtype ID: Sendable & Hashable & Codable

    /// Unique identifier for this instance
    ///
    /// - Auto-generated: `var id: String = ULID().ulidString`
    /// - User-defined: Any type conforming to TupleElement
    ///
    /// **Important**: `id` is not included in the generated initializer.
    /// It is always auto-initialized with its default value.
    var id: ID { get }

    // MARK: - Metadata (Storage-independent)

    /// Type identifier for this persistable type
    ///
    /// This is the canonical name used across all layers to identify the type.
    /// Can be customized via `@Persistable(type: "CustomName")`.
    ///
    /// **Examples**:
    /// - Default: struct name (e.g., "User", "Product")
    /// - Custom: `@Persistable(type: "User")` on a `Member` struct
    static var persistableType: String { get }

    /// All field names in the persistable type
    ///
    /// Includes all stored properties (including `id`), in declaration order.
    ///
    /// **Example**: `["id", "email", "name", "createdAt"]`
    static var allFields: [String] { get }

    /// All descriptors for this persistable type
    ///
    /// Contains all metadata descriptors including:
    /// - `IndexDescriptor`: Generated from `#Index<T>` macro
    /// - `RelationshipDescriptor`: Generated from `@Relationship` macro (Relationship module)
    /// - Future: `EncryptionDescriptor`, `TTLDescriptor`, etc.
    ///
    /// **Type-safe access**:
    /// Each module provides extension methods for type-safe access:
    /// - `indexDescriptors` (Core)
    /// - `relationshipDescriptors` (Relationship module)
    ///
    /// **Example**:
    /// ```swift
    /// // Access all descriptors
    /// let allDescriptors = User.descriptors
    ///
    /// // Type-safe access via extensions
    /// let indexes = User.indexDescriptors
    /// let relationships = User.relationshipDescriptors  // requires Relationship module
    /// ```
    static var descriptors: [any Descriptor] { get }

    // MARK: - Directory Metadata

    /// Directory path components for FDB storage
    ///
    /// Generated from `#Directory<T>` macro declarations.
    /// Contains a mix of static `Path` and dynamic `Field` components.
    ///
    /// **Example**:
    /// ```swift
    /// #Directory<User>("app", "users")
    /// // → [Path("app"), Path("users")]
    ///
    /// #Directory<Order>("tenants", Field(\.tenantID), "orders")
    /// // → [Path("tenants"), Field(\.tenantID), Path("orders")]
    /// ```
    ///
    /// **Default**: Returns `[Path(persistableType)]` if not specified via macro.
    static var directoryPathComponents: [any DirectoryPathElement] { get }

    /// Directory layer type for FDB storage
    ///
    /// Generated from `#Directory<T>` macro's `layer:` parameter.
    ///
    /// **Example**:
    /// ```swift
    /// #Directory<User>("app", "users")
    /// // → .default
    ///
    /// #Directory<Order>("tenants", Field(\.tenantID), "orders", layer: .partition)
    /// // → .partition
    /// ```
    ///
    /// **Default**: `.default` if not specified via macro.
    static var directoryLayer: DirectoryLayer { get }

    /// Field-level type metadata for all persisted fields
    ///
    /// Provides name, Protobuf field number, type, optionality, and array status
    /// for each field. Used by schema registries and dynamic codecs to
    /// decode/encode data without requiring the compiled type.
    ///
    /// **Implementation**: Generated by @Persistable macro
    ///
    /// **Example**:
    /// ```swift
    /// @Persistable
    /// struct User {
    ///     var email: String
    ///     var age: Int = 0
    /// }
    ///
    /// User.fieldSchemas
    /// // [FieldSchema(name: "id", fieldNumber: 1, type: .string, ...),
    /// //  FieldSchema(name: "email", fieldNumber: 2, type: .string, ...),
    /// //  FieldSchema(name: "age", fieldNumber: 3, type: .int, ...)]
    /// ```
    static var fieldSchemas: [FieldSchema] { get }

    /// Get field number for a field name (for Protobuf serialization)
    ///
    /// Used by serialization layers that require stable field numbering.
    ///
    /// - Parameter fieldName: The field name
    /// - Returns: Field number, or nil if field doesn't exist or numbering is not defined
    static func fieldNumber(for fieldName: String) -> Int?

    /// Get enum metadata for a field (if the field is an enum)
    ///
    /// Provides enum case information for validation and serialization.
    ///
    /// - Parameter fieldName: The field name
    /// - Returns: EnumMetadata if field is an enum, nil otherwise
    static func enumMetadata(for fieldName: String) -> EnumMetadata?

    // MARK: - Field-Level Security

    /// Static metadata about fields marked with `@Restricted`
    ///
    /// Generated by `@Persistable` macro for each `@Restricted` field.
    /// This metadata is compile-time constant and does not change after decode.
    ///
    /// **Usage**:
    /// ```swift
    /// @Persistable
    /// struct Employee {
    ///     @Restricted(read: .roles(["hr"]), write: .roles(["hr"]))
    ///     var salary: Double = 0
    /// }
    ///
    /// // Access static metadata
    /// let metadata = Employee.restrictedFieldsMetadata
    /// // → [RestrictedFieldMetadata(fieldName: "salary", readAccess: .roles(["hr"]), ...)]
    /// ```
    static var restrictedFieldsMetadata: [RestrictedFieldMetadata] { get }

    /// Create a copy with restricted fields masked to default values
    ///
    /// Generated by `@Persistable` macro. Fields that the auth context cannot read
    /// are replaced with their type's default values.
    ///
    /// **Usage**:
    /// ```swift
    /// let employee = Employee(name: "Alice", salary: 100000)
    /// let regularUserAuth = TestAuth(userID: "user1", roles: ["employee"])
    ///
    /// let masked = employee.masked(auth: regularUserAuth)
    /// // masked.salary == 0 (default value, because user lacks "hr" role)
    /// // masked.name == "Alice" (unchanged)
    /// ```
    ///
    /// - Parameter auth: Authentication context (nil = unauthenticated)
    /// - Returns: Copy with restricted fields masked
    func masked(auth: (any AuthContext)?) -> Self

    // MARK: - Dynamic Field Access

    /// Access field values dynamically by name
    ///
    /// Enables runtime field access using string-based field names.
    /// This is used by DataAccess for KeyExpression evaluation and index building.
    ///
    /// **Implementation**: Generated by @Persistable macro
    ///
    /// **Example**:
    /// ```swift
    /// @Persistable
    /// struct User {
    ///     var email: String
    /// }
    ///
    /// let user = User(email: "user@example.com")
    /// let email = user[dynamicMember: "email"]  // Optional<any Sendable>
    /// ```
    ///
    /// - Parameter member: Field name to access
    /// - Returns: Field value as Sendable, or nil if field doesn't exist
    subscript(dynamicMember member: String) -> (any Sendable)? { get }

    // MARK: - KeyPath Support

    /// Convert a KeyPath to its field name string representation
    ///
    /// **Implementation**: Generated by @Persistable macro
    ///
    /// **Example**:
    /// ```swift
    /// @Persistable
    /// struct User {
    ///     var email: String
    ///     var address: Address
    /// }
    ///
    /// User.fieldName(for: \.email)           // "email"
    /// User.fieldName(for: \.address.city)    // "address.city"
    /// ```
    ///
    /// - Parameter keyPath: KeyPath to convert
    /// - Returns: Dot-notation field name string
    static func fieldName<Value>(for keyPath: KeyPath<Self, Value>) -> String

    /// Convert a PartialKeyPath to its field name string representation
    ///
    /// - Parameter keyPath: PartialKeyPath to convert
    /// - Returns: Dot-notation field name string
    static func fieldName(for keyPath: PartialKeyPath<Self>) -> String

    /// Convert an AnyKeyPath to its field name string representation
    ///
    /// Used when the concrete type is erased. Falls back to KeyPath description
    /// if the keyPath doesn't belong to this type.
    ///
    /// - Parameter keyPath: AnyKeyPath to convert
    /// - Returns: Dot-notation field name string
    static func fieldName(for keyPath: AnyKeyPath) -> String
}

// MARK: - Default Implementations

public extension Persistable {
    /// Default implementation returns empty array (no descriptors)
    static var descriptors: [any Descriptor] { [] }

    /// Type-safe access to index descriptors
    ///
    /// Filters `descriptors` to return only `IndexDescriptor` instances.
    static var indexDescriptors: [IndexDescriptor] {
        descriptors.compactMap { $0 as? IndexDescriptor }
    }

    /// Default implementation uses persistableType as single path component
    ///
    /// If `#Directory` macro is not used, defaults to `[Path(persistableType)]`.
    /// For example, `User` type → directory path `["User"]`.
    ///
    /// **Note**: @Persistable macro always generates explicit implementations,
    /// which override this default for macro-decorated types.
    static var directoryPathComponents: [any DirectoryPathElement] {
        [Path(persistableType)]
    }

    /// Default implementation returns `.default` layer
    ///
    /// If `#Directory` macro is not used, defaults to `.default` layer.
    ///
    /// **Note**: @Persistable macro always generates explicit implementations,
    /// which override this default for macro-decorated types.
    static var directoryLayer: DirectoryLayer { .default }

    /// Default implementation returns empty array (no field schemas)
    static var fieldSchemas: [FieldSchema] { [] }

    /// Default implementation returns nil (no field numbers)
    static func fieldNumber(for fieldName: String) -> Int? { nil }

    /// Default implementation returns nil (no enum metadata)
    static func enumMetadata(for fieldName: String) -> EnumMetadata? { nil }

    /// Default implementation returns empty array (no restricted fields)
    static var restrictedFieldsMetadata: [RestrictedFieldMetadata] { [] }

    /// Default implementation returns self unchanged (no masking)
    func masked(auth: (any AuthContext)?) -> Self { self }

    /// Default implementation for fieldName - returns KeyPath description
    ///
    /// **Note**: @Persistable macro generates a proper implementation.
    /// This default is for types that don't use the macro.
    static func fieldName<Value>(for keyPath: KeyPath<Self, Value>) -> String {
        "\(keyPath)"
    }

    /// Default implementation for fieldName (PartialKeyPath version)
    static func fieldName(for keyPath: PartialKeyPath<Self>) -> String {
        "\(keyPath)"
    }

    /// Default implementation for fieldName (AnyKeyPath version)
    ///
    /// Attempts to cast to PartialKeyPath<Self> and delegate, otherwise uses description.
    static func fieldName(for keyPath: AnyKeyPath) -> String {
        if let partialKeyPath = keyPath as? PartialKeyPath<Self> {
            return fieldName(for: partialKeyPath)
        }
        return "\(keyPath)"
    }

    /// Register this type for index building during migrations (optional)
    ///
    /// **Default Implementation**: Does nothing.
    ///
    /// **Note**: This method is provided for backward compatibility and advanced
    /// use cases. The primary index building flow uses `_EntityIndexBuildable`
    /// protocol, which automatically works for all `Persistable & Codable` types.
    ///
    /// **FDBIndexing Override**: For `Persistable & Codable` types,
    /// FDBIndexing provides a specialized implementation that registers
    /// the type with `IndexBuilderRegistry` for optional manual registry usage.
    static func registerForIndexBuilding() {
        // Default: do nothing
        // FDBIndexing provides specialized implementation for Codable types
    }
}
