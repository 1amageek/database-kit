/// @Persistable macro declaration
///
/// Generates Persistable protocol conformance with metadata methods and ID management.
///
/// **Supports all data model layers**:
/// - RecordLayer (RDB): Structured records with indexes
/// - DocumentLayer (DocumentDB): Flexible documents
/// - VectorLayer (Vector search): Use #Index with VectorIndexKind
/// - GraphLayer (GraphDB): Define nodes and edges with relationships
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct User {
///     var id: String = ULID().ulidString  // Optional: auto-generated if omitted
///
///     #Directory<User>("users")
///     #Index<User>(ScalarIndexKind(fields: [\.email]), unique: true)
///
///     var email: String
///     var name: String
/// }
/// ```
///
/// **With custom type name** (for renaming stability):
/// ```swift
/// @Persistable(type: "User")
/// struct Member {
///     var id: String = ULID().ulidString
///     var name: String
/// }
/// // persistableType = "User" (not "Member")
/// ```
///
/// **Generated code**:
/// - `var id: String = ULID().ulidString` (if not user-defined)
/// - `static var persistableType: String`
/// - `static var allFields: [String]`
/// - `static var indexDescriptors: [IndexDescriptor]`
/// - `static func fieldNumber(for fieldName: String) -> Int?`
/// - `static func enumMetadata(for fieldName: String) -> EnumMetadata?`
/// - `init(...)` (without `id` parameter)
///
/// **ID Behavior**:
/// - If user defines `id` field: uses that type and default value
/// - If user omits `id` field: macro adds `var id: String = ULID().ulidString`
/// - `id` is NOT included in the generated initializer
@attached(member, names: named(id), named(persistableType), named(allFields), named(indexDescriptors), named(relationshipDescriptors), named(directoryPathComponents), named(directoryLayer), named(fieldNumber), named(enumMetadata), named(subscript), named(init), named(fieldName), named(CodingKeys), arbitrary)
@attached(extension, conformances: Persistable, Codable, Sendable)
public macro Persistable() = #externalMacro(module: "CoreMacros", type: "PersistableMacro")

/// @Persistable macro with custom type name
///
/// **Usage**:
/// ```swift
/// @Persistable(type: "User")
/// struct Member {
///     var name: String
/// }
/// // persistableType = "User"
/// ```
@attached(member, names: named(id), named(persistableType), named(allFields), named(indexDescriptors), named(relationshipDescriptors), named(directoryPathComponents), named(directoryLayer), named(fieldNumber), named(enumMetadata), named(subscript), named(init), named(fieldName), named(CodingKeys), arbitrary)
@attached(extension, conformances: Persistable, Codable, Sendable)
public macro Persistable(type: String) = #externalMacro(module: "CoreMacros", type: "PersistableMacro")

/// #Index macro declaration
///
/// Declares an index on specified fields. IndexKind owns the field information
/// and generates its own index name.
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct Product {
///     var id: String = ULID().ulidString
///
///     // Scalar index for sorting and range queries
///     #Index<Product>(ScalarIndexKind(fields: [\.email]), unique: true)
///     #Index<Product>(ScalarIndexKind(fields: [\.category, \.price]))
///
///     // Aggregation indexes
///     #Index<Product>(CountIndexKind(groupBy: [\.category]))
///     #Index<Product>(SumIndexKind(groupBy: [\.category], value: \.price))
///     #Index<Product>(MinIndexKind(groupBy: [\.category], value: \.price))
///     #Index<Product>(MaxIndexKind(groupBy: [\.category], value: \.price))
///
///     var email: String
///     var category: String
///     var price: Int
/// }
/// ```
///
/// This is a marker macro. The @Persistable macro reads the #Index declaration
/// and generates the indexDescriptors array.
///
/// **Parameters**:
/// - type: IndexKind implementation (contains field information)
/// - unique: Uniqueness constraint (default: false)
/// - name: Custom index name (default: auto-generated by IndexKind)
///
/// **Standard Index Kinds** (FDB-independent):
/// - `ScalarIndexKind(fields:)`: VALUE index for sorting and range queries
/// - `CountIndexKind(groupBy:)`: Count aggregation by grouping fields
/// - `SumIndexKind(groupBy:value:)`: Sum aggregation by grouping fields
/// - `MinIndexKind(groupBy:value:)`: Minimum value tracking by grouping fields
/// - `MaxIndexKind(groupBy:value:)`: Maximum value tracking by grouping fields
/// - `AverageIndexKind(groupBy:value:)`: Average value tracking by grouping fields
/// - `VersionIndexKind(field:strategy:)`: Version tracking index
///
/// **Extended Index Kinds** (from fdb-indexes package - FDB-dependent):
/// - `VectorIndexKind`: Vector similarity search (HNSW, IVF, flat scan)
/// - `FullTextIndexKind`: Full-text search with inverted index
/// - `AdjacencyIndexKind`: Graph adjacency index
/// - Custom third-party implementations
///
/// **Index Name Generation**:
/// Each IndexKind generates its own index name from its type and field names:
/// - ScalarIndexKind: `{TypeName}_{field1}_{field2}`
/// - CountIndexKind: `{TypeName}_count_{field1}_{field2}`
/// - SumIndexKind: `{TypeName}_sum_{groupFields}__{valueField}`
/// - etc.
///
/// **How it works**:
/// 1. Macro extracts KeyPath literals (\.xxx) from IndexKind constructor
/// 2. KeyPaths are converted to field names via Root.fieldName(for:)
/// 3. IndexKind.indexName generates the index name from type and field names
@freestanding(declaration)
public macro Index<T: Persistable>(
    _ type: any IndexKind,
    unique: Bool = false,
    name: String? = nil
) = #externalMacro(module: "CoreMacros", type: "IndexMacro")

/// #Directory macro declaration
///
/// Declares directory path for a persistable type (for FDBRuntime).
///
/// **Usage**:
/// ```swift
/// #Directory<User>("app", "users")
/// #Directory<Order>("tenants", Field(\.tenantID), "orders", layer: .partition)
/// ```
///
/// This macro validates the directory path syntax. The actual directory
/// functionality is provided by FDBRuntime.
@freestanding(declaration)
public macro Directory<T>(_ elements: Any..., layer: DirectoryLayer = .default) = #externalMacro(module: "CoreMacros", type: "DirectoryMacro")

/// Directory layer type
///
/// Used by #Directory macro to specify the directory layer type.
public enum DirectoryLayer: String, Sendable, Codable {
    /// Default directory
    case `default` = "default"

    /// Multi-tenant partition (requires at least one Field in path)
    case partition = "partition"
}

// Note: Field<Root> is defined in DirectoryPathElement.swift
// It conforms to DirectoryPathElement protocol for type-safe directory paths.

// MARK: - @Polymorphable Macro

/// @Polymorphable macro declaration
///
/// Generates Polymorphable protocol conformance for a protocol definition.
/// Enables multiple Persistable types to share a directory and indexes,
/// allowing them to be queried together.
///
/// **Usage**:
/// ```swift
/// @Polymorphable
/// protocol Document: Polymorphable {  // Must explicitly inherit from Polymorphable
///     var id: String { get }
///     var title: String { get }
///     var updatedAt: Date { get }
///
///     #Directory<Document>("app", "documents")
///     #Index<Document>(ScalarIndexKind(fields: [\.title]), name: "Document_title")
/// }
///
/// @Persistable
/// struct Article: Document {
///     var id: String = ULID().ulidString
///     var title: String
///     var updatedAt: Date
///     var content: String
/// }
///
/// @Persistable
/// struct Report: Document {
///     var id: String = ULID().ulidString
///     var title: String
///     var updatedAt: Date
///     var data: Data
/// }
/// ```
///
/// **Important**: The protocol must explicitly inherit from `Polymorphable`.
/// The macro generates default implementations for the protocol requirements.
///
/// **Generated code**:
/// - `static var polymorphableType: String` - Protocol name identifier
/// - `static var polymorphicDirectoryPathComponents: [any DirectoryPathElement]` - Shared directory
/// - `static var polymorphicDirectoryLayer: DirectoryLayer` - Directory layer type
/// - `static var polymorphicIndexDescriptors: [IndexDescriptor]` - Shared indexes
///
/// **Server-side Usage**:
/// ```swift
/// // Schema includes all conforming types
/// let schema = Schema([Article.self, Report.self, ...])
///
/// // Polymorphic fetch - retrieves all types conforming to the protocol
/// // NOTE: Use a concrete conforming type (not the protocol type itself)
/// // due to Swift's type system limitation with existential metatypes
/// let docs = try await context.fetchPolymorphic(Article.self)
/// // Returns [any Persistable] containing both Article and Report instances
/// ```
///
/// **Dual-Write Behavior**:
/// When a conforming type has its own `#Directory` (different from the protocol's):
/// - Save: Data written to both type-specific AND polymorphic directories
/// - Delete: Data removed from both directories
///
/// **Swift Type System Note**:
/// Protocol types cannot be passed to generic functions requiring `Polymorphable`:
/// ```swift
/// // ❌ Compile error: 'any Document' cannot conform to 'Polymorphable'
/// try await context.fetchPolymorphic(Document.self)
///
/// // ✅ Use any concrete conforming type (all share the same polymorphic directory)
/// try await context.fetchPolymorphic(Article.self)
/// ```
///
/// **Storage Layout**:
/// All conforming types share the same directory with type code prefix:
/// ```
/// [polymorphic-directory]/R/[typeCode]/[id] → protobuf
/// [type-directory]/R/[PersistableType]/[id] → protobuf (if dual-write)
/// ```
@attached(member, names: named(polymorphableType), named(polymorphicDirectoryPathComponents), named(polymorphicDirectoryLayer), named(polymorphicIndexDescriptors))
@attached(extension, names: named(polymorphableType), named(polymorphicDirectoryPathComponents), named(polymorphicDirectoryLayer), named(polymorphicIndexDescriptors))
public macro Polymorphable() = #externalMacro(module: "CoreMacros", type: "PolymorphableMacro")

// MARK: - @Transient Macro

/// @Transient macro declaration
///
/// Marks a property as transient (excluded from persistence and allFields).
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct User {
///     var id: String = ULID().ulidString
///     var email: String
///     var name: String
///
///     @Transient
///     var cachedFullName: String?  // Not persisted to database
///
///     @Transient
///     var isOnline: Bool = false   // Runtime-only state
/// }
/// ```
///
/// **Effects**:
/// - Field is excluded from `allFields` array
/// - Field is excluded from Codable serialization
/// - Field is excluded from generated initializer
/// - Field is excluded from `subscript(dynamicMember:)`
///
/// **Requirements**:
/// - Field must have a default value (since it's excluded from initializer)
@attached(peer)
public macro Transient() = #externalMacro(module: "CoreMacros", type: "TransientMacro")

// MARK: - @Reference Macro (Test)

/// @Reference macro declaration - TEST for circular reference behavior
///
/// Tests if type references in macros cause circular dependency issues.
///
/// **Usage**:
/// ```swift
/// struct A {
///     @Reference(B.self)
///     var bId: String?
/// }
///
/// struct B {
///     @Reference(A.self)
///     var aId: String?
/// }
/// ```
@attached(peer)
public macro Reference<T>(_ type: T.Type) = #externalMacro(module: "CoreMacros", type: "ReferenceMacro")
