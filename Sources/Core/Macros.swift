/// @Persistable macro declaration
///
/// Generates Persistable protocol conformance with metadata methods and ID management.
///
/// **Supports all data model layers**:
/// - RecordLayer (RDB): Structured records with indexes
/// - DocumentLayer (DocumentDB): Flexible documents
/// - VectorLayer (Vector search): Use #Index with VectorIndexKind
/// - GraphLayer (GraphDB): Define nodes and edges with relationships
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct User {
///     var id: String = ULID().ulidString  // Optional: auto-generated if omitted
///
///     #Directory<User>("users")
///     #Index<User>(ScalarIndexKind(fields: [\.email]), unique: true)
///
///     var email: String
///     var name: String
/// }
/// ```
///
/// **With custom type name** (for renaming stability):
/// ```swift
/// @Persistable(type: "User")
/// struct Member {
///     var id: String = ULID().ulidString
///     var name: String
/// }
/// // persistableType = "User" (not "Member")
/// ```
///
/// **Generated code**:
/// - `var id: String = ULID().ulidString` (if not user-defined)
/// - `static var persistableType: String`
/// - `static var allFields: [String]`
/// - `static var indexDescriptors: [IndexDescriptor]`
/// - `static func fieldNumber(for fieldName: String) -> Int?`
/// - `static func enumMetadata(for fieldName: String) -> EnumMetadata?`
/// - `init(...)` (without `id` parameter)
///
/// **ID Behavior**:
/// - If user defines `id` field: uses that type and default value
/// - If user omits `id` field: macro adds `var id: String = ULID().ulidString`
/// - `id` is NOT included in the generated initializer
@attached(member, names: named(id), named(persistableType), named(allFields), named(indexDescriptors), named(directoryPathComponents), named(directoryLayer), named(fieldNumber), named(enumMetadata), named(subscript), named(init), named(fieldName), named(CodingKeys))
@attached(extension, conformances: Persistable, Codable, Sendable)
public macro Persistable() = #externalMacro(module: "CoreMacros", type: "PersistableMacro")

/// @Persistable macro with custom type name
///
/// **Usage**:
/// ```swift
/// @Persistable(type: "User")
/// struct Member {
///     var name: String
/// }
/// // persistableType = "User"
/// ```
@attached(member, names: named(id), named(persistableType), named(allFields), named(indexDescriptors), named(directoryPathComponents), named(directoryLayer), named(fieldNumber), named(enumMetadata), named(subscript), named(init), named(fieldName), named(CodingKeys))
@attached(extension, conformances: Persistable, Codable, Sendable)
public macro Persistable(type: String) = #externalMacro(module: "CoreMacros", type: "PersistableMacro")

/// #Index macro declaration
///
/// Declares an index on specified fields. IndexKind owns the field information
/// and generates its own index name.
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct Product {
///     var id: String = ULID().ulidString
///
///     // Scalar index for sorting and range queries
///     #Index<Product>(ScalarIndexKind(fields: [\.email]), unique: true)
///     #Index<Product>(ScalarIndexKind(fields: [\.category, \.price]))
///
///     // Aggregation indexes
///     #Index<Product>(CountIndexKind(groupBy: [\.category]))
///     #Index<Product>(SumIndexKind(groupBy: [\.category], value: \.price))
///     #Index<Product>(MinIndexKind(groupBy: [\.category], value: \.price))
///     #Index<Product>(MaxIndexKind(groupBy: [\.category], value: \.price))
///
///     var email: String
///     var category: String
///     var price: Int
/// }
/// ```
///
/// This is a marker macro. The @Persistable macro reads the #Index declaration
/// and generates the indexDescriptors array.
///
/// **Parameters**:
/// - type: IndexKind implementation (contains field information)
/// - unique: Uniqueness constraint (default: false)
/// - name: Custom index name (default: auto-generated by IndexKind)
///
/// **Standard Index Kinds** (FDB-independent):
/// - `ScalarIndexKind(fields:)`: VALUE index for sorting and range queries
/// - `CountIndexKind(groupBy:)`: Count aggregation by grouping fields
/// - `SumIndexKind(groupBy:value:)`: Sum aggregation by grouping fields
/// - `MinIndexKind(groupBy:value:)`: Minimum value tracking by grouping fields
/// - `MaxIndexKind(groupBy:value:)`: Maximum value tracking by grouping fields
/// - `AverageIndexKind(groupBy:value:)`: Average value tracking by grouping fields
/// - `VersionIndexKind(field:strategy:)`: Version tracking index
///
/// **Extended Index Kinds** (from fdb-indexes package - FDB-dependent):
/// - `VectorIndexKind`: Vector similarity search (HNSW, IVF, flat scan)
/// - `FullTextIndexKind`: Full-text search with inverted index
/// - `AdjacencyIndexKind`: Graph adjacency index
/// - Custom third-party implementations
///
/// **Index Name Generation**:
/// Each IndexKind generates its own index name from its type and field names:
/// - ScalarIndexKind: `{TypeName}_{field1}_{field2}`
/// - CountIndexKind: `{TypeName}_count_{field1}_{field2}`
/// - SumIndexKind: `{TypeName}_sum_{groupFields}__{valueField}`
/// - etc.
///
/// **How it works**:
/// 1. Macro extracts KeyPath literals (\.xxx) from IndexKind constructor
/// 2. KeyPaths are converted to field names via Root.fieldName(for:)
/// 3. IndexKind.indexName generates the index name from type and field names
@freestanding(declaration)
public macro Index<T: Persistable>(
    _ type: any IndexKind,
    unique: Bool = false,
    name: String? = nil
) = #externalMacro(module: "CoreMacros", type: "IndexMacro")

/// #Directory macro declaration
///
/// Declares directory path for a persistable type (for FDBRuntime).
///
/// **Usage**:
/// ```swift
/// #Directory<User>("app", "users")
/// #Directory<Order>("tenants", Field(\.tenantID), "orders", layer: .partition)
/// ```
///
/// This macro validates the directory path syntax. The actual directory
/// functionality is provided by FDBRuntime.
@freestanding(declaration)
public macro Directory<T>(_ elements: Any..., layer: DirectoryLayer = .default) = #externalMacro(module: "CoreMacros", type: "DirectoryMacro")

/// Directory layer type
///
/// Used by #Directory macro to specify the directory layer type.
public enum DirectoryLayer: String, Sendable, Codable {
    /// Default directory
    case `default` = "default"

    /// Multi-tenant partition (requires at least one Field in path)
    case partition = "partition"
}

// Note: Field<Root> is defined in DirectoryPathElement.swift
// It conforms to DirectoryPathElement protocol for type-safe directory paths.

// MARK: - @Transient Macro

/// @Transient macro declaration
///
/// Marks a property as transient (excluded from persistence and allFields).
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct User {
///     var id: String = ULID().ulidString
///     var email: String
///     var name: String
///
///     @Transient
///     var cachedFullName: String?  // Not persisted to database
///
///     @Transient
///     var isOnline: Bool = false   // Runtime-only state
/// }
/// ```
///
/// **Effects**:
/// - Field is excluded from `allFields` array
/// - Field is excluded from Codable serialization
/// - Field is excluded from generated initializer
/// - Field is excluded from `subscript(dynamicMember:)`
///
/// **Requirements**:
/// - Field must have a default value (since it's excluded from initializer)
@attached(peer)
public macro Transient() = #externalMacro(module: "CoreMacros", type: "TransientMacro")
