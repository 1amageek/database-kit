/// FieldSchema - Field-level type metadata for Persistable types
///
/// Provides compile-time metadata about each field's name, type, and Protobuf field number.
/// Generated by `@Persistable` macro. Used by schema registries and dynamic codecs
/// to decode/encode data without requiring the compiled `@Persistable` type.
///
/// **Design**: Analogous to PostgreSQL's `pg_attribute` catalog.

/// Schema metadata for a single field of a Persistable type
public struct FieldSchema: Sendable, Codable, Equatable {
    /// Field name (e.g., "email", "price")
    public let name: String

    /// Protobuf field number (1-based, sequential)
    public let fieldNumber: Int

    /// Scalar type of the field
    public let type: FieldSchemaType

    /// Whether the field is Optional
    public let isOptional: Bool

    /// Whether the field is an Array
    public let isArray: Bool

    public init(
        name: String,
        fieldNumber: Int,
        type: FieldSchemaType,
        isOptional: Bool = false,
        isArray: Bool = false
    ) {
        self.name = name
        self.fieldNumber = fieldNumber
        self.type = type
        self.isOptional = isOptional
        self.isArray = isArray
    }
}

/// Scalar type classification for field schema
///
/// Maps Swift types to a finite set of wire-compatible categories.
/// Used by dynamic Protobuf codecs to interpret raw bytes without compiled types.
public enum FieldSchemaType: String, Sendable, Codable, Equatable {
    case string
    case int
    case int8
    case int16
    case int32
    case int64
    case uint
    case uint8
    case uint16
    case uint32
    case uint64
    case double
    case float
    case bool
    case date
    case uuid
    case data
    /// Nested Persistable type (encoded as length-delimited Protobuf)
    case nested
    /// Enum type (encoded as varint or string depending on raw value)
    case `enum`

    /// Resolve field schema type at runtime for types the macro cannot classify at compile time.
    ///
    /// The `@Persistable` macro generates `FieldSchemaType.resolve(TypeName.self)` for
    /// non-primitive types. At runtime, this checks `RawRepresentable` conformance
    /// to distinguish enums from nested Persistable types.
    ///
    /// - Parameter type: The Swift type to classify
    /// - Returns: `.enum` if the type conforms to `RawRepresentable`, `.nested` otherwise
    public static func resolve(_ type: Any.Type) -> FieldSchemaType {
        if type is any RawRepresentable.Type {
            return .enum
        }
        return .nested
    }
}
