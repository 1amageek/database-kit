// Relationship.swift
// Core - Relationship types and macro for Persistable types
//
// Reference: SwiftData @Relationship macro
// https://developer.apple.com/documentation/swiftdata/relationship

// MARK: - DeleteRule

/// Delete rule when the owning model is deleted
///
/// Controls what happens to related models when the model owning
/// the relationship is deleted.
///
/// **Reference**: SwiftData `Schema.Relationship.DeleteRule`
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct Order {
///     @Relationship(Customer.self, deleteRule: .cascade)
///     var customerID: String?
/// }
/// ```
public enum DeleteRule: String, Sendable, Codable, Hashable {
    /// Set related model's property to nil (default)
    ///
    /// When the owning model is deleted, the foreign key in related
    /// models is set to nil, breaking the relationship but preserving
    /// the related records.
    ///
    /// **Example**: Deleting a Customer sets `order.customerID = nil`
    /// for all related Orders.
    case nullify

    /// Delete all related models
    ///
    /// When the owning model is deleted, all related models are also
    /// deleted recursively.
    ///
    /// **Warning**: Be careful with bidirectional cascade rules to
    /// avoid infinite deletion loops.
    ///
    /// **Example**: Deleting a Customer also deletes all their Orders.
    case cascade

    /// Prevent deletion if related models exist
    ///
    /// Throws an error if attempting to delete a model that has
    /// existing relationships. The user must delete or reassign
    /// related models first.
    ///
    /// **Example**: Cannot delete a Customer if they have Orders.
    case deny

    /// Do nothing (may leave orphans)
    ///
    /// The relationship is not maintained on deletion. Related models
    /// may reference a deleted model (orphaned foreign keys).
    ///
    /// **Use Case**: When orphaned references are acceptable or
    /// cleanup is handled elsewhere.
    case noAction
}

// MARK: - RelationshipDescriptor

/// Descriptor for a relationship between Persistable types
///
/// Generated by the `@Persistable` macro when it detects `@Relationship`
/// attributes. Contains all metadata needed to maintain the relationship
/// at runtime.
///
/// **Usage**:
/// ```swift
/// // Access relationship metadata
/// let descriptors = Order.relationshipDescriptors
/// for descriptor in descriptors {
///     print("Relationship: \(descriptor.propertyName) -> \(descriptor.relatedTypeName)")
/// }
/// ```
public struct RelationshipDescriptor: Sendable, Hashable, Codable {
    // MARK: - Properties

    /// FK field name in the owning type
    ///
    /// Example: For `@Relationship(Customer.self) var customerID: String?`,
    /// this is `"customerID"`
    public let propertyName: String

    /// Name of the related Persistable type
    ///
    /// Example: For `@Relationship(Customer.self)`, this is `"Customer"`
    public let relatedTypeName: String

    /// Delete rule for this relationship
    ///
    /// Determines what happens to related items when the owning item is deleted.
    public let deleteRule: DeleteRule

    /// Whether this is a to-many relationship
    ///
    /// - `true`: `var orderIDs: [String]` (array of FK)
    /// - `false`: `var customerID: String?` (single optional FK)
    public let isToMany: Bool

    /// Relationship property name (derived from FK field name)
    ///
    /// - `"customerID"` → `"customer"`
    /// - `"orderIDs"` → `"orders"`
    ///
    /// Used for generating Snapshot extension properties.
    public let relationshipPropertyName: String

    // MARK: - Initialization

    public init(
        propertyName: String,
        relatedTypeName: String,
        deleteRule: DeleteRule,
        isToMany: Bool,
        relationshipPropertyName: String
    ) {
        self.propertyName = propertyName
        self.relatedTypeName = relatedTypeName
        self.deleteRule = deleteRule
        self.isToMany = isToMany
        self.relationshipPropertyName = relationshipPropertyName
    }

    /// Convenience initializer that derives relationshipPropertyName from propertyName
    public init(
        propertyName: String,
        relatedTypeName: String,
        deleteRule: DeleteRule,
        isToMany: Bool
    ) {
        self.propertyName = propertyName
        self.relatedTypeName = relatedTypeName
        self.deleteRule = deleteRule
        self.isToMany = isToMany
        self.relationshipPropertyName = Self.deriveRelationshipName(
            from: propertyName,
            isToMany: isToMany
        )
    }

    // MARK: - Computed Properties

    /// Whether this is a to-one relationship
    public var isToOne: Bool {
        !isToMany
    }

    /// Index name for this relationship
    ///
    /// Format: `{OwnerType}_{relationshipPropertyName}`
    /// Used for the relationship index in FoundationDB.
    public func indexName(for ownerType: String) -> String {
        "\(ownerType)_\(relationshipPropertyName)"
    }

    // MARK: - Static Methods

    /// Derive relationship property name from FK field name
    ///
    /// - `"customerID"` → `"customer"`
    /// - `"orderIDs"` → `"orders"`
    public static func deriveRelationshipName(from fkFieldName: String, isToMany: Bool) -> String {
        if isToMany {
            // "orderIDs" → "orders"
            // Remove "IDs" suffix and add "s"
            let base = fkFieldName.replacingOccurrences(of: "IDs", with: "")
            return base + "s"
        } else {
            // "customerID" → "customer"
            return fkFieldName.replacingOccurrences(of: "ID", with: "")
        }
    }
}

// MARK: - CustomStringConvertible

extension RelationshipDescriptor: CustomStringConvertible {
    public var description: String {
        let cardinality = isToMany ? "to-many" : "to-one"
        return "RelationshipDescriptor(\(propertyName) -> \(relatedTypeName), \(cardinality), \(deleteRule))"
    }
}

// MARK: - @Relationship Macro Declaration

/// Declares a relationship between Persistable types
///
/// The `@Relationship` macro marks a FK field as a relationship to another
/// Persistable type. It enables:
/// - Automatic relationship index generation
/// - Delete rule enforcement
/// - Snapshot property generation for easy access
///
/// ## FK Field Naming Convention
///
/// - To-One: `xxxxID` (e.g., `customerID: String?`)
/// - To-Many: `xxxxIDs` (e.g., `orderIDs: [String]`)
///
/// The macro generates Snapshot extensions that provide cleaner access:
/// - `customerID` → `snapshot.customer`
/// - `orderIDs` → `snapshot.orders`
///
/// ## Usage
///
/// ```swift
/// @Persistable
/// struct Order {
///     var total: Double
///
///     // To-One: FK to Customer
///     @Relationship(Customer.self, deleteRule: .nullify)
///     var customerID: String?
/// }
///
/// @Persistable
/// struct Customer {
///     var name: String
///
///     // To-Many: array of FK to Order
///     @Relationship(Order.self, deleteRule: .cascade)
///     var orderIDs: [String] = []
/// }
///
/// @Persistable
/// struct Employee {
///     var name: String
///
///     // Self-referencing relationship
///     @Relationship(Employee.self, deleteRule: .nullify)
///     var managerID: String?
/// }
/// ```
///
/// ## Querying with Relationships
///
/// ```swift
/// // Load orders with customer data
/// let orders = try await context.fetch(Order.self)
///     .joining(\.customerID)
///     .execute()
///
/// for order in orders {
///     print(order.customer?.name)  // Direct access via generated property
/// }
/// ```
///
/// ## Delete Rules
///
/// - `.nullify` (default): Set related item's FK to nil
/// - `.cascade`: Delete all related items
/// - `.deny`: Throw error if related items exist
/// - `.noAction`: Do nothing (may leave orphans)
///
/// - Parameters:
///   - type: The related Persistable type (e.g., `Customer.self`)
///   - deleteRule: Action to take when the related model is deleted (default: `.nullify`)
@attached(peer)
public macro Relationship<T>(
    _ type: T.Type,
    deleteRule: DeleteRule = .nullify
) = #externalMacro(module: "CoreMacros", type: "RelationshipMacro")
